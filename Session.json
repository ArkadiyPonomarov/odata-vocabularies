{
    "$Version": "4.0",
    "$Reference": {
        "https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Core.V1.json": {
            "$Include": [
                {
                    "$Alias": "Core",
                    "$Namespace": "Org.OData.Core.V1"
                }
            ]
        },
        "https://wiki.scn.sap.com/wiki/download/attachments/448470974/Common.xml?api=v2": {
            "$Include": [
                {
                    "$Namespace": "com.sap.vocabularies.Common.v1",
                    "$Alias": "Common"
                }
            ]
        }
    },
    "com.sap.vocabularies.Session.v1": {
        "$Alias": "Session",
        "@Common.Experimental": true,
        "@Core.Description": "Terms for services requiring sticky sessions for data modification",
        "@Core.Description#Published": "2018-07-26 Â© Copyright 2018 SAP SE. All rights reserved",
        "@Core.Links": [
            {
                "rel": "latest-version",
                "href": "https://wiki.scn.sap.com/wiki/download/attachments/462030211/Session.xml?api=v2"
            },
            {
                "rel": "describedby",
                "href": "https://wiki.scn.sap.com/wiki/x/gwWKGw"
            }
        ],
        "@Core.LongDescription": "\nBuilding REST APIs on top of ABAP code that has been written for classic session-based communication is hard and sometimes not economically feasible.\n\nHTTP is not connection-based, meaning that each request may be sent over a different TCP connection. \nAdding scalable servers and load balancers into the mix, each individual HTTP request is typically answered by a different application server instance.\n\nSticky sessions to the rescue: session stickiness or session affinity is a mechanism to route (HTTP) calls from the same client instance to the same \"session\", \n\"work process\", or \"application instance\".  This is a performance improvement measure because it allows the server to keep server state in process-specific memory.\nThis process-specific memory is lost if the server process instance crashes, in which case the client is redirected to another process instance.\nIn modern, scalable server environments sticky sessions are usually combined with a persistency service to allow recovering session state after \na process instance crash, so from the client's perspective the server state is kept. In the case of ABAP servers the session state is simply lost.\n\nSession stickiness is usually achieved via a cookie containing the session id. This has the benefit that browser-based applications don't need to be aware \nof the session stickiness because browsers automatically send cookies on subsequent requests. \nHowever, cookies are shared across browser tabs and windows, and requests from different tabs or windows would be dispatched to the same server session.\nAgain this poses a problem for classic ABAP code which was built under the assumption that each server session is tied to at most one client instance.\n\nThis means that the client application has to be aware of the service's limitations and cooperate to route calls from each client instance (browser tab or window) \nto a different server session. The ABAP server allows this by sending the session id in the response header `sap-contextid`, \nwhich client instances will need to echo in subsequent requests.\n\nAlso the client needs to adhere to a strict choreography of \n- initiate session\n- send data modification and read requests\n- end session by either\n  - confirm data modification or\n  - discard changes\n\nThis choreography is (intentionally) similar to the choreography for [Draft Handling](https://experience.sap.com/fiori-design-web/draft-handling/).\n\nData modification requests will fail outside of a session. This is a safety mechanism for clients that do not know the session choreography.\n        ",
        "StickySessionRequired": {
            "$Kind": "Term",
            "$Nullable": true,
            "$Type": "Session.StickySessionRequiredType",
            "$AppliesTo": [
                "EntitySet"
            ],
            "@Common.Experimental": true,
            "@Core.Description": "The annotated entity set allows data modification only within a sticky session"
        },
        "StickySessionRequiredType": {
            "$Kind": "ComplexType",
            "@Common.Experimental": true,
            "@Core.Description": "Actions for managing data modification within a sticky session",
            "NewActions": {
                "$Collection": true,
                "$Type": "Common.QualifiedName",
                "@Core.Description": "List of bound actions that initiate a sticky session and create a new entity",
                "@Core.LongDescription": "Multiple actions are allowed to support 'create by reference' from different sources."
            },
            "EditAction": {
                "$Type": "Common.QualifiedName",
                "@Core.Description": "Bound action that initiates a sticky session for editing the targeted entity"
            },
            "PreparationAction": {
                "$Type": "Common.QualifiedName",
                "@Core.Description": "Bound action that prepares (checks, auto-fills) an entity"
            },
            "SaveAction": {
                "$Type": "Common.QualifiedName",
                "@Core.Description": "Bound action that saves a new or edited entity",
                "@Core.LongDescription": "On success this action returns the newly created or edited entity and the sticky session is terminated. On failure the sticky session is kept alive."
            },
            "DiscardAction": {
                "$Type": "Common.SimpleIdentifier",
                "@Core.Description": "Action import for an unbound action that discards all changes and terminates the sticky session"
            }
        }
    }
}
